// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fossfab.proto

#ifndef PROTOBUF_fossfab_2eproto__INCLUDED
#define PROTOBUF_fossfab_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace FossFab {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_fossfab_2eproto();
void protobuf_AssignDesc_fossfab_2eproto();
void protobuf_ShutdownFile_fossfab_2eproto();

class Command;
class HeadPosition;
class Mesh;
class Slice;
class Triangle;
class Vector3;

enum Command_CommandCode {
  Command_CommandCode_MOVE = 0,
  Command_CommandCode_RENDER_MESH = 1,
  Command_CommandCode_RENDER_PATH = 2,
  Command_CommandCode_RENDER_SLICES = 3,
  Command_CommandCode_RESET = 4,
  Command_CommandCode_Command_CommandCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Command_CommandCode_Command_CommandCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Command_CommandCode_IsValid(int value);
const Command_CommandCode Command_CommandCode_CommandCode_MIN = Command_CommandCode_MOVE;
const Command_CommandCode Command_CommandCode_CommandCode_MAX = Command_CommandCode_RESET;
const int Command_CommandCode_CommandCode_ARRAYSIZE = Command_CommandCode_CommandCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_CommandCode_descriptor();
inline const ::std::string& Command_CommandCode_Name(Command_CommandCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_CommandCode_descriptor(), value);
}
inline bool Command_CommandCode_Parse(
    const ::std::string& name, Command_CommandCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_CommandCode>(
    Command_CommandCode_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_CommandCode CommandCode;
  static const CommandCode MOVE =
    Command_CommandCode_MOVE;
  static const CommandCode RENDER_MESH =
    Command_CommandCode_RENDER_MESH;
  static const CommandCode RENDER_PATH =
    Command_CommandCode_RENDER_PATH;
  static const CommandCode RENDER_SLICES =
    Command_CommandCode_RENDER_SLICES;
  static const CommandCode RESET =
    Command_CommandCode_RESET;
  static inline bool CommandCode_IsValid(int value) {
    return Command_CommandCode_IsValid(value);
  }
  static const CommandCode CommandCode_MIN =
    Command_CommandCode_CommandCode_MIN;
  static const CommandCode CommandCode_MAX =
    Command_CommandCode_CommandCode_MAX;
  static const int CommandCode_ARRAYSIZE =
    Command_CommandCode_CommandCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandCode_descriptor() {
    return Command_CommandCode_descriptor();
  }
  static inline const ::std::string& CommandCode_Name(CommandCode value) {
    return Command_CommandCode_Name(value);
  }
  static inline bool CommandCode_Parse(const ::std::string& name,
      CommandCode* value) {
    return Command_CommandCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .FossFab.Command.CommandCode command_code = 1;
  void clear_command_code();
  static const int kCommandCodeFieldNumber = 1;
  ::FossFab::Command_CommandCode command_code() const;
  void set_command_code(::FossFab::Command_CommandCode value);

  // repeated .FossFab.HeadPosition positions = 2;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 2;
  const ::FossFab::HeadPosition& positions(int index) const;
  ::FossFab::HeadPosition* mutable_positions(int index);
  ::FossFab::HeadPosition* add_positions();
  ::google::protobuf::RepeatedPtrField< ::FossFab::HeadPosition >*
      mutable_positions();
  const ::google::protobuf::RepeatedPtrField< ::FossFab::HeadPosition >&
      positions() const;

  // optional .FossFab.Mesh mesh = 3;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 3;
  const ::FossFab::Mesh& mesh() const;
  ::FossFab::Mesh* mutable_mesh();
  ::FossFab::Mesh* release_mesh();
  void set_allocated_mesh(::FossFab::Mesh* mesh);

  // optional bool extrude = 4;
  void clear_extrude();
  static const int kExtrudeFieldNumber = 4;
  bool extrude() const;
  void set_extrude(bool value);

  // repeated .FossFab.Slice slices = 5;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 5;
  const ::FossFab::Slice& slices(int index) const;
  ::FossFab::Slice* mutable_slices(int index);
  ::FossFab::Slice* add_slices();
  ::google::protobuf::RepeatedPtrField< ::FossFab::Slice >*
      mutable_slices();
  const ::google::protobuf::RepeatedPtrField< ::FossFab::Slice >&
      slices() const;

  // @@protoc_insertion_point(class_scope:FossFab.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::FossFab::HeadPosition > positions_;
  int command_code_;
  bool extrude_;
  ::FossFab::Mesh* mesh_;
  ::google::protobuf::RepeatedPtrField< ::FossFab::Slice > slices_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Slice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.Slice) */ {
 public:
  Slice();
  virtual ~Slice();

  Slice(const Slice& from);

  inline Slice& operator=(const Slice& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slice& default_instance();

  void Swap(Slice* other);

  // implements Message ----------------------------------------------

  inline Slice* New() const { return New(NULL); }

  Slice* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Slice& from);
  void MergeFrom(const Slice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FossFab.Vector3 positions = 1;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 1;
  const ::FossFab::Vector3& positions(int index) const;
  ::FossFab::Vector3* mutable_positions(int index);
  ::FossFab::Vector3* add_positions();
  ::google::protobuf::RepeatedPtrField< ::FossFab::Vector3 >*
      mutable_positions();
  const ::google::protobuf::RepeatedPtrField< ::FossFab::Vector3 >&
      positions() const;

  // @@protoc_insertion_point(class_scope:FossFab.Slice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::FossFab::Vector3 > positions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static Slice* default_instance_;
};
// -------------------------------------------------------------------

class Triangle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.Triangle) */ {
 public:
  Triangle();
  virtual ~Triangle();

  Triangle(const Triangle& from);

  inline Triangle& operator=(const Triangle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Triangle& default_instance();

  void Swap(Triangle* other);

  // implements Message ----------------------------------------------

  inline Triangle* New() const { return New(NULL); }

  Triangle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Triangle& from);
  void MergeFrom(const Triangle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Triangle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FossFab.Vector3 vertex1 = 1;
  bool has_vertex1() const;
  void clear_vertex1();
  static const int kVertex1FieldNumber = 1;
  const ::FossFab::Vector3& vertex1() const;
  ::FossFab::Vector3* mutable_vertex1();
  ::FossFab::Vector3* release_vertex1();
  void set_allocated_vertex1(::FossFab::Vector3* vertex1);

  // optional .FossFab.Vector3 vertex2 = 2;
  bool has_vertex2() const;
  void clear_vertex2();
  static const int kVertex2FieldNumber = 2;
  const ::FossFab::Vector3& vertex2() const;
  ::FossFab::Vector3* mutable_vertex2();
  ::FossFab::Vector3* release_vertex2();
  void set_allocated_vertex2(::FossFab::Vector3* vertex2);

  // optional .FossFab.Vector3 vertex3 = 3;
  bool has_vertex3() const;
  void clear_vertex3();
  static const int kVertex3FieldNumber = 3;
  const ::FossFab::Vector3& vertex3() const;
  ::FossFab::Vector3* mutable_vertex3();
  ::FossFab::Vector3* release_vertex3();
  void set_allocated_vertex3(::FossFab::Vector3* vertex3);

  // @@protoc_insertion_point(class_scope:FossFab.Triangle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::FossFab::Vector3* vertex1_;
  ::FossFab::Vector3* vertex2_;
  ::FossFab::Vector3* vertex3_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static Triangle* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.Mesh) */ {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh& default_instance();

  void Swap(Mesh* other);

  // implements Message ----------------------------------------------

  inline Mesh* New() const { return New(NULL); }

  Mesh* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FossFab.Triangle triangles = 1;
  int triangles_size() const;
  void clear_triangles();
  static const int kTrianglesFieldNumber = 1;
  const ::FossFab::Triangle& triangles(int index) const;
  ::FossFab::Triangle* mutable_triangles(int index);
  ::FossFab::Triangle* add_triangles();
  ::google::protobuf::RepeatedPtrField< ::FossFab::Triangle >*
      mutable_triangles();
  const ::google::protobuf::RepeatedPtrField< ::FossFab::Triangle >&
      triangles() const;

  // @@protoc_insertion_point(class_scope:FossFab.Mesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::FossFab::Triangle > triangles_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:FossFab.Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class HeadPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FossFab.HeadPosition) */ {
 public:
  HeadPosition();
  virtual ~HeadPosition();

  HeadPosition(const HeadPosition& from);

  inline HeadPosition& operator=(const HeadPosition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadPosition& default_instance();

  void Swap(HeadPosition* other);

  // implements Message ----------------------------------------------

  inline HeadPosition* New() const { return New(NULL); }

  HeadPosition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeadPosition& from);
  void MergeFrom(const HeadPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeadPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FossFab.Vector3 pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::FossFab::Vector3& pos() const;
  ::FossFab::Vector3* mutable_pos();
  ::FossFab::Vector3* release_pos();
  void set_allocated_pos(::FossFab::Vector3* pos);

  // @@protoc_insertion_point(class_scope:FossFab.HeadPosition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::FossFab::Vector3* pos_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_fossfab_2eproto();
  friend void protobuf_AssignDesc_fossfab_2eproto();
  friend void protobuf_ShutdownFile_fossfab_2eproto();

  void InitAsDefaultInstance();
  static HeadPosition* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Command

// optional .FossFab.Command.CommandCode command_code = 1;
inline void Command::clear_command_code() {
  command_code_ = 0;
}
inline ::FossFab::Command_CommandCode Command::command_code() const {
  // @@protoc_insertion_point(field_get:FossFab.Command.command_code)
  return static_cast< ::FossFab::Command_CommandCode >(command_code_);
}
inline void Command::set_command_code(::FossFab::Command_CommandCode value) {
  
  command_code_ = value;
  // @@protoc_insertion_point(field_set:FossFab.Command.command_code)
}

// repeated .FossFab.HeadPosition positions = 2;
inline int Command::positions_size() const {
  return positions_.size();
}
inline void Command::clear_positions() {
  positions_.Clear();
}
inline const ::FossFab::HeadPosition& Command::positions(int index) const {
  // @@protoc_insertion_point(field_get:FossFab.Command.positions)
  return positions_.Get(index);
}
inline ::FossFab::HeadPosition* Command::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:FossFab.Command.positions)
  return positions_.Mutable(index);
}
inline ::FossFab::HeadPosition* Command::add_positions() {
  // @@protoc_insertion_point(field_add:FossFab.Command.positions)
  return positions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::FossFab::HeadPosition >*
Command::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:FossFab.Command.positions)
  return &positions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::FossFab::HeadPosition >&
Command::positions() const {
  // @@protoc_insertion_point(field_list:FossFab.Command.positions)
  return positions_;
}

// optional .FossFab.Mesh mesh = 3;
inline bool Command::has_mesh() const {
  return !_is_default_instance_ && mesh_ != NULL;
}
inline void Command::clear_mesh() {
  if (GetArenaNoVirtual() == NULL && mesh_ != NULL) delete mesh_;
  mesh_ = NULL;
}
inline const ::FossFab::Mesh& Command::mesh() const {
  // @@protoc_insertion_point(field_get:FossFab.Command.mesh)
  return mesh_ != NULL ? *mesh_ : *default_instance_->mesh_;
}
inline ::FossFab::Mesh* Command::mutable_mesh() {
  
  if (mesh_ == NULL) {
    mesh_ = new ::FossFab::Mesh;
  }
  // @@protoc_insertion_point(field_mutable:FossFab.Command.mesh)
  return mesh_;
}
inline ::FossFab::Mesh* Command::release_mesh() {
  // @@protoc_insertion_point(field_release:FossFab.Command.mesh)
  
  ::FossFab::Mesh* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline void Command::set_allocated_mesh(::FossFab::Mesh* mesh) {
  delete mesh_;
  mesh_ = mesh;
  if (mesh) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FossFab.Command.mesh)
}

// optional bool extrude = 4;
inline void Command::clear_extrude() {
  extrude_ = false;
}
inline bool Command::extrude() const {
  // @@protoc_insertion_point(field_get:FossFab.Command.extrude)
  return extrude_;
}
inline void Command::set_extrude(bool value) {
  
  extrude_ = value;
  // @@protoc_insertion_point(field_set:FossFab.Command.extrude)
}

// repeated .FossFab.Slice slices = 5;
inline int Command::slices_size() const {
  return slices_.size();
}
inline void Command::clear_slices() {
  slices_.Clear();
}
inline const ::FossFab::Slice& Command::slices(int index) const {
  // @@protoc_insertion_point(field_get:FossFab.Command.slices)
  return slices_.Get(index);
}
inline ::FossFab::Slice* Command::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:FossFab.Command.slices)
  return slices_.Mutable(index);
}
inline ::FossFab::Slice* Command::add_slices() {
  // @@protoc_insertion_point(field_add:FossFab.Command.slices)
  return slices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::FossFab::Slice >*
Command::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:FossFab.Command.slices)
  return &slices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::FossFab::Slice >&
Command::slices() const {
  // @@protoc_insertion_point(field_list:FossFab.Command.slices)
  return slices_;
}

// -------------------------------------------------------------------

// Slice

// repeated .FossFab.Vector3 positions = 1;
inline int Slice::positions_size() const {
  return positions_.size();
}
inline void Slice::clear_positions() {
  positions_.Clear();
}
inline const ::FossFab::Vector3& Slice::positions(int index) const {
  // @@protoc_insertion_point(field_get:FossFab.Slice.positions)
  return positions_.Get(index);
}
inline ::FossFab::Vector3* Slice::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:FossFab.Slice.positions)
  return positions_.Mutable(index);
}
inline ::FossFab::Vector3* Slice::add_positions() {
  // @@protoc_insertion_point(field_add:FossFab.Slice.positions)
  return positions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::FossFab::Vector3 >*
Slice::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:FossFab.Slice.positions)
  return &positions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::FossFab::Vector3 >&
Slice::positions() const {
  // @@protoc_insertion_point(field_list:FossFab.Slice.positions)
  return positions_;
}

// -------------------------------------------------------------------

// Triangle

// optional .FossFab.Vector3 vertex1 = 1;
inline bool Triangle::has_vertex1() const {
  return !_is_default_instance_ && vertex1_ != NULL;
}
inline void Triangle::clear_vertex1() {
  if (GetArenaNoVirtual() == NULL && vertex1_ != NULL) delete vertex1_;
  vertex1_ = NULL;
}
inline const ::FossFab::Vector3& Triangle::vertex1() const {
  // @@protoc_insertion_point(field_get:FossFab.Triangle.vertex1)
  return vertex1_ != NULL ? *vertex1_ : *default_instance_->vertex1_;
}
inline ::FossFab::Vector3* Triangle::mutable_vertex1() {
  
  if (vertex1_ == NULL) {
    vertex1_ = new ::FossFab::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:FossFab.Triangle.vertex1)
  return vertex1_;
}
inline ::FossFab::Vector3* Triangle::release_vertex1() {
  // @@protoc_insertion_point(field_release:FossFab.Triangle.vertex1)
  
  ::FossFab::Vector3* temp = vertex1_;
  vertex1_ = NULL;
  return temp;
}
inline void Triangle::set_allocated_vertex1(::FossFab::Vector3* vertex1) {
  delete vertex1_;
  vertex1_ = vertex1;
  if (vertex1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FossFab.Triangle.vertex1)
}

// optional .FossFab.Vector3 vertex2 = 2;
inline bool Triangle::has_vertex2() const {
  return !_is_default_instance_ && vertex2_ != NULL;
}
inline void Triangle::clear_vertex2() {
  if (GetArenaNoVirtual() == NULL && vertex2_ != NULL) delete vertex2_;
  vertex2_ = NULL;
}
inline const ::FossFab::Vector3& Triangle::vertex2() const {
  // @@protoc_insertion_point(field_get:FossFab.Triangle.vertex2)
  return vertex2_ != NULL ? *vertex2_ : *default_instance_->vertex2_;
}
inline ::FossFab::Vector3* Triangle::mutable_vertex2() {
  
  if (vertex2_ == NULL) {
    vertex2_ = new ::FossFab::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:FossFab.Triangle.vertex2)
  return vertex2_;
}
inline ::FossFab::Vector3* Triangle::release_vertex2() {
  // @@protoc_insertion_point(field_release:FossFab.Triangle.vertex2)
  
  ::FossFab::Vector3* temp = vertex2_;
  vertex2_ = NULL;
  return temp;
}
inline void Triangle::set_allocated_vertex2(::FossFab::Vector3* vertex2) {
  delete vertex2_;
  vertex2_ = vertex2;
  if (vertex2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FossFab.Triangle.vertex2)
}

// optional .FossFab.Vector3 vertex3 = 3;
inline bool Triangle::has_vertex3() const {
  return !_is_default_instance_ && vertex3_ != NULL;
}
inline void Triangle::clear_vertex3() {
  if (GetArenaNoVirtual() == NULL && vertex3_ != NULL) delete vertex3_;
  vertex3_ = NULL;
}
inline const ::FossFab::Vector3& Triangle::vertex3() const {
  // @@protoc_insertion_point(field_get:FossFab.Triangle.vertex3)
  return vertex3_ != NULL ? *vertex3_ : *default_instance_->vertex3_;
}
inline ::FossFab::Vector3* Triangle::mutable_vertex3() {
  
  if (vertex3_ == NULL) {
    vertex3_ = new ::FossFab::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:FossFab.Triangle.vertex3)
  return vertex3_;
}
inline ::FossFab::Vector3* Triangle::release_vertex3() {
  // @@protoc_insertion_point(field_release:FossFab.Triangle.vertex3)
  
  ::FossFab::Vector3* temp = vertex3_;
  vertex3_ = NULL;
  return temp;
}
inline void Triangle::set_allocated_vertex3(::FossFab::Vector3* vertex3) {
  delete vertex3_;
  vertex3_ = vertex3;
  if (vertex3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FossFab.Triangle.vertex3)
}

// -------------------------------------------------------------------

// Mesh

// repeated .FossFab.Triangle triangles = 1;
inline int Mesh::triangles_size() const {
  return triangles_.size();
}
inline void Mesh::clear_triangles() {
  triangles_.Clear();
}
inline const ::FossFab::Triangle& Mesh::triangles(int index) const {
  // @@protoc_insertion_point(field_get:FossFab.Mesh.triangles)
  return triangles_.Get(index);
}
inline ::FossFab::Triangle* Mesh::mutable_triangles(int index) {
  // @@protoc_insertion_point(field_mutable:FossFab.Mesh.triangles)
  return triangles_.Mutable(index);
}
inline ::FossFab::Triangle* Mesh::add_triangles() {
  // @@protoc_insertion_point(field_add:FossFab.Mesh.triangles)
  return triangles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::FossFab::Triangle >*
Mesh::mutable_triangles() {
  // @@protoc_insertion_point(field_mutable_list:FossFab.Mesh.triangles)
  return &triangles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::FossFab::Triangle >&
Mesh::triangles() const {
  // @@protoc_insertion_point(field_list:FossFab.Mesh.triangles)
  return triangles_;
}

// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:FossFab.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:FossFab.Vector3.x)
}

// optional float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:FossFab.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:FossFab.Vector3.y)
}

// optional float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:FossFab.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:FossFab.Vector3.z)
}

// -------------------------------------------------------------------

// HeadPosition

// optional .FossFab.Vector3 pos = 1;
inline bool HeadPosition::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
inline void HeadPosition::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::FossFab::Vector3& HeadPosition::pos() const {
  // @@protoc_insertion_point(field_get:FossFab.HeadPosition.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::FossFab::Vector3* HeadPosition::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::FossFab::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:FossFab.HeadPosition.pos)
  return pos_;
}
inline ::FossFab::Vector3* HeadPosition::release_pos() {
  // @@protoc_insertion_point(field_release:FossFab.HeadPosition.pos)
  
  ::FossFab::Vector3* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void HeadPosition::set_allocated_pos(::FossFab::Vector3* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FossFab.HeadPosition.pos)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace FossFab

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::FossFab::Command_CommandCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FossFab::Command_CommandCode>() {
  return ::FossFab::Command_CommandCode_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fossfab_2eproto__INCLUDED
